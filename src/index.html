<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>WebGPU-Notes</title>
    <style>
        html {
            font-size: 10px;
        }

        body {
            overflow: hidden;
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: #383838;
            color: #fff;
            font-family: Arial, sans-serif;
            font-size: 16px;
        }

        pre {
            overflow-x: auto;
            border-radius: 0.6rem;
        }

        iframe {
            border: none;
            overflow: hidden;
            width: 40rem;
            height: 30rem;
            /* 1. 禁止用户选中文字（双击不会变蓝，也不会触发编辑意图） */
            user-select: none;
            /* 2. 强制隐藏光标（即便浏览器误以为可以编辑，光标也看不见） */
            caret-color: transparent;
        }

        a {
            /* 去掉默认的下划线 */
            text-decoration: none !important;
            color: #ec3d95 !important;
            position: relative;
        }

        a::after {
            content: "";
            position: absolute;
            left: 0;
            bottom: -2px;
            width: 100%;
            height: 2px;
            background: #f3267c !important;
            transform: scaleX(0);
            transition: transform 0.3s ease;
            transform-origin: right;
        }

        a:hover::after {
            transform: scaleX(1);
            transform-origin: left;
        }

        input[type="text"] {
            width: 20rem;
            height: 2.5rem;
            border: 0.2rem solid #ddd;
            border-radius: 0.8rem;
            font-size: 1.4rem;
            outline: none;
            transition: all 0.3s ease;
            background: #fff;
            box-shadow: 0 0.2rem 0.5rem rgba(0, 0, 0, 0.1);
            text-indent: 0.5rem;
        }

        input[type="text"]:focus {
            border-color: #c43393;
            box-shadow: 0 0 0.8rem rgba(156, 35, 82, 0.5);
        }

        input[type="text"]::placeholder {
            color: #aaa;
            font-style: italic;
        }

        button {
            padding: 0.7rem 1.2rem;
            font-weight: bold;
            color: #fff;
            border: none;
            border-radius: 0.6rem;
            background: linear-gradient(135deg, #ff7eb3, #a18cd1);
            backdrop-filter: blur(1rem);
            box-shadow: 0 0.4rem 2rem rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            opacity: 0.8;
            transform: translateY(-0.2rem);
            box-shadow: 0 0.6rem 2.5rem rgba(0, 0, 0, 0.25);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 0.3rem 1rem rgba(0, 0, 0, 0.3);
        }

        dialog {
            box-sizing: border-box;
            padding: 2rem;
            min-width: 50%;
            max-width: 80%;
            width: fit-content;
            background: rgba(175, 175, 175, 0.3);
            color: #fff;
            border: none;
            border-radius: 1rem;
            box-shadow: 0 0.8rem 2.4rem rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(1rem);
        }

        dialog::backdrop {
            background: rgba(0, 0, 0, 0.4);
        }

        /* 1. 设置滚动条的整体宽度 */
        ::-webkit-scrollbar {
            /* 纵向滚动条宽度 */
            width: 0.8rem;
            /* 横向滚动条高度 */
            height: 0.8rem;
        }

        /* 2. 轨道样式 */
        ::-webkit-scrollbar-track {
            background: linear-gradient(135deg, #4a4a4a, #404040);
            /* 轨道的颜色 */
            border-radius: 1rem;
            /* 轨道圆角 */
        }

        /* 3. 滑块样式 */
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #ff7eb3, #a18cd1);
            /* 滑块默认颜色 */
            border-radius: 1rem;
            /* 滑块圆角 */
            border: 1px solid #f55;
            /* 技巧：用边框撑开间隙，产生“悬浮”感 */
        }

        /* 4. 鼠标悬停在滑块上的效果 */
        ::-webkit-scrollbar-thumb:hover {
            /* 悬停时变深 */
            background: linear-gradient(135deg, #c85f8b, #7d63b9);
        }

        #header {
            position: sticky;
            top: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            height: 5rem;
            background: #1a1a1a;
            z-index: 1;
        }

        #search {
            display: flex;
            align-items: center;
        }

        #main {
            display: flex;
            width: 100%;
            height: calc(100% - 5rem);
        }

        #toc-container {
            overflow-y: auto;
            position: sticky;
            max-width: 30rem;
            height: 100%;
            background: rgba(70, 50, 60, 0.7);
            backdrop-filter: blur(1rem);
        }

        .toc-list {
            list-style: none;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
            width: 100%;
        }

        .toc-list a {
            text-decoration: none;
            font-size: 1.4rem;
            line-height: 2;
        }

        .toc-list a:hover {
            color: #007bff;
        }

        /* 针对深层级的特殊样式 */
        .toc-list ul {
            /* 去掉默认的小圆点 */
            list-style: none;
            padding-left: 1.5rem;
            border-left: 1px solid #eee;
        }

        /* 激活状态 */
        .toc-list .toc-link.active {
            color: #ff7b00 !important;
        }

        .toc-list .toc-link.active::after {
            background: #ff7b00 !important;
        }

        #article {
            overflow-y: auto;
            flex: 1;
        }

        #content {
            margin: 0 auto;
            padding: 2rem;
            max-width: 90rem;
            background: #252525;
            border-radius: 0.8rem;
            box-shadow: 0 0.2rem 0.6rem rgba(0, 0, 0, 0.2);
        }

        .highlight {
            color: red;
            font-weight: bold;
        }
    </style>
    <!-- 引入 marked.js -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- 引入 GitHub Markdown CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.css">
    <!-- 白天模式 -->
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/default.min.css"> -->
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js/styles/github.min.css"> -->
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js/styles/atom-one-light.min.css"> -->
    <!-- 夜间模式 -->
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js/styles/monokai.min.css"> -->
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js/styles/github-dark.min.css"> -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js/styles/atom-one-dark.min.css">
    <!-- 引入 highlight.js -->
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script>
    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/rust.min.js"></script>
    <!-- 引入 katex -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
</head>

<body>
    <header id="header">
        <div></div>
        <div id="search">
            <input type="text" placeholder="请输入关键字...">
            <button style="margin-left:0.5rem; margin-right: 1rem;">搜索</button>
        </div>
    </header>
    <main id="main">
        <nav id="toc-container"></nav>
        <article id="article">
            <div id="content" class="markdown-body"></div>
        </article>
    </main>
    <dialog id="dialog">
        <h2>搜索结果</h2>
        <ul id="search-result"></ul>
    </dialog>
    <script src="./assets/js/utils.js"></script>
    <script>
        // http://127.0.0.1:5500/src
        // http://127.0.0.1:5500/src/
        // http://127.0.0.1:5500/src/index.html
        // http://127.0.0.1:5500/src/index.html#/docs/webgpu.md
        // 重定向
        if (!location.href.includes('index.html#/')) {
            const url = location.href.replace(/\/src\/.*/, '/src/index.html#/docs/webgpu.md')
            location.href = url
        }

        // 配置 marked 使用 highlight.js 
        marked.setOptions({
            highlight: function (code, lang) {
                if (lang === 'wgsl') {
                    lang = 'rust'; // 替换成 rust
                }
                // 如果指定了语言，尝试用对应的高亮 
                if (lang && hljs.getLanguage(lang)) {
                    return hljs.highlight(code, { language: lang }).value;
                }
                // 否则自动检测 
                return hljs.highlightAuto(code).value;
            }
        });
        // 自定义渲染器，给标题加上 id
        const renderer = {
            heading(o) {
                const { text, depth } = o;
                const idKey = text.replace(/#/g, '').trim().toLowerCase();
                const id = getId(idKey);
                return `<h${depth} id="${id}">${text}</h${depth}>`;
            }
        };
        marked.use({ renderer });
        // 1. 定义扩展逻辑
        const katexExtension = {
            name: 'math',
            level: 'inline', // 处理行内公式
            start(src) { return src.indexOf('$'); }, // 找到 $ 开始处理
            tokenizer(src) {
                // 匹配 $$公式$$ (块级) 或 $公式$ (行内)
                const rule = /^(\$\$|内容)([\s\S]*?)\1/;
                // 注意：这里为了严谨，通常使用更复杂的正则，以下为简化示意：
                const match = src.match(/^\$\$([\s\S]+?)\$\$/) || src.match(/^\$([^$\n]+?)\$/);
                if (match) {
                    return {
                        type: 'math',
                        raw: match[0],
                        text: match[1].trim(),
                        displayMode: match[0].startsWith('$$') // 是否为块级公式
                    };
                }
            },
            renderer(token) {
                return katex.renderToString(token.text, {
                    displayMode: token.displayMode,
                    throwOnError: false
                });
            }
        };

        // 2. 告知 Marked 使用该扩展
        marked.use({ extensions: [katexExtension] });
        // const renderer = new marked.Renderer();
        // // 重写 link 方法 
        // renderer.link = function (o) { return `<a href="${o.href}" target="_blank" rel="noopener noreferrer">${o.text}</a>`; };
        // // 使用自定义 renderer 
        // marked.setOptions({ renderer });

        const content = document.getElementById('content');
        // 1. 定义路由表
        const routes = {
            '#/docs/webgpu.md': './docs/webgpu.md',
            '#/docs/details/1-Triangle.md': './docs/details/1-Triangle.md',
            '#/docs/details/ai.md': './docs/details/ai.md',
            '#/docs/details/gpu.md': './docs/details/gpu.md',
        };

        // 2. 路由渲染函数
        async function router() {
            // 获取当前的 hash，如果没有则默认跳转到首页
            const path = window.location.hash || '#/docs/webgpu.md';
            const url = routes[path] || path.replace('#/', './');
            // 根据 hash 渲染对应的 HTML
            await parseMarkdown(url, content);
            const qs = getQueryParam()
            if (qs.id) {
                const element = document.getElementById(qs.id);
                if (element) {
                    if (qs.keyword) {
                        highlightKeywords(qs.keyword, content);
                    }
                    // 滚动到高亮位置
                    element.scrollIntoView({ behavior: 'smooth', block: "start" });
                }
            }

            // 生成目录
            const headers = Array.from(content.querySelectorAll('h1, h2, h3, h4')).map(h => ({
                level: parseInt(h.tagName.replace('H', '')),
                text: h.innerText,
                id: h.id
            }));

            const tocHtml = generateNestedTOC(headers);
            document.getElementById('toc-container').innerHTML = tocHtml;

            // 滚动自动点亮
            const observer = new IntersectionObserver(entries => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const currentId = entry.target.id;

                        // 1. 点亮目录项样式
                        document.querySelectorAll('.toc-link').forEach(link => {
                            link.classList.toggle('active', link.dataset.id === currentId);
                        });

                        // 2. 自动更新地址栏（?id=xxx）
                        switchUrlId(currentId);
                    }
                });
            }, { rootMargin: '-10% 0px -85% 0px' });

            document.querySelectorAll('h1, h2, h3, h4').forEach(h => observer.observe(h));
        }

        // 3. 监听 hash 变化
        window.addEventListener('hashchange', router);

        // 4. 页面首次加载时执行一次
        window.addEventListener('load', router);

        window.addEventListener("popstate", () => {
            const qs = getQueryParam()
            if (qs.id) {
                const element = document.getElementById(qs.id);
                if (element) {
                    if (qs.keyword) {
                        highlightKeywords(qs.keyword, content);
                    }
                    // 滚动到高亮位置
                    element.scrollIntoView({ behavior: 'smooth', block: "start" });
                }
            }
        });

        // 搜索功能
        async function search(keyword) {
            const mds = []
            const targets = []
            for (const key in routes) {
                const url = routes[key];
                const text = await readMarkDown(url);
                const md = { url, text }
                mds.push(md)
            }
            for (const md of mds) {
                const text = md.text;
                const results = searchWithContext(text, keyword)
                for (let i = 0; i < results.length; i++) {
                    const result = results[i];
                    const target = { ...md, ...result }
                    targets.push(target)
                }
            }
            return targets;
        }
        const searchInput = document.querySelector('#search input');
        const searchButton = document.querySelector('#search button');
        const dialog = document.querySelector('#dialog');
        const ul = document.querySelector('#search-result');
        addEventListener('click', (event) => {
            if (event.target === dialog) {
                dialog.close();
            }
        });
        searchButton.addEventListener('click', async () => {
            const keyword = searchInput.value.trim();
            if (keyword) {
                dialog.showModal(); // showModal() 表示模态对话框
                const mds = await search(keyword)
                ul.innerHTML = '';
                for (const md of mds) {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    const url = md.url.replace('./', '#/')
                    const idKey = md.anchor.replace(/#/g, '').trim().toLowerCase();
                    const id = getId(idKey)
                    const fullUrl = `/src/index.html${url}`
                    a.href = `${fullUrl}?id=${id}&keyword=${keyword}`;
                    const res = getKeywordContext(md.text, keyword, 15)[0]
                    // const text = highlightKeyword(md.text, keyword)
                    const text = `${res.before}<span class="highlight">${res.keyword}</span>${res.after}`
                    a.innerHTML = `${md.url}: ${text}`;
                    li.appendChild(a);
                    ul.appendChild(li);
                }
            }
        });
    </script>
</body>

</html>